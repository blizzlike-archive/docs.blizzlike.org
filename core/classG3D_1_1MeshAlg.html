<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>blizzlike core: G3D::MeshAlg Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">blizzlike core
   </div>
   <div id="projectbrief">mmorpg server</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>G3D</b></li><li class="navelem"><a class="el" href="classG3D_1_1MeshAlg.html">MeshAlg</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="classG3D_1_1MeshAlg-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">G3D::MeshAlg Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="MeshAlg_8h_source.html">MeshAlg.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1MeshAlg_1_1Edge.html">Edge</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1MeshAlg_1_1Face.html">Face</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1MeshAlg_1_1Geometry.html">Geometry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1MeshAlg_1_1Vertex.html">Vertex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a764b82b69eb915de51242b58f9eeb615"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classG3D_1_1PrimitiveType.html">PrimitiveType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1MeshAlg.html#a764b82b69eb915de51242b58f9eeb615">Primitive</a></td></tr>
<tr class="separator:a764b82b69eb915de51242b58f9eeb615"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af9c7e0c436b7ea572b49c138e66fe1e1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1MeshAlg.html#af9c7e0c436b7ea572b49c138e66fe1e1">computeAdjacency</a> (const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;vertexGeometry, const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; int &gt; &amp;indexArray, <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1MeshAlg_1_1Face.html">Face</a> &gt; &amp;faceArray, <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1MeshAlg_1_1Edge.html">Edge</a> &gt; &amp;edgeArray, <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1MeshAlg_1_1Vertex.html">Vertex</a> &gt; &amp;vertexArray)</td></tr>
<tr class="separator:af9c7e0c436b7ea572b49c138e66fe1e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7523393a6241ffdccc3e40485e4688ad"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1MeshAlg.html#a7523393a6241ffdccc3e40485e4688ad">computeAdjacency</a> (const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;vertexArray, const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; int &gt; &amp;indexArray, <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1MeshAlg_1_1Face.html">Face</a> &gt; &amp;faceArray, <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1MeshAlg_1_1Edge.html">Edge</a> &gt; &amp;edgeArray, <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; int &gt; &gt; &amp;facesAdjacentToVertex)</td></tr>
<tr class="separator:a7523393a6241ffdccc3e40485e4688ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa1d0cd2ffbc8cff5bdfb1abe58cb11"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1MeshAlg.html#a8aa1d0cd2ffbc8cff5bdfb1abe58cb11">computeAreaStatistics</a> (const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;vertexArray, const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; int &gt; &amp;indexArray, double &amp;minEdgeLength, double &amp;meanEdgeLength, double &amp;medianEdgeLength, double &amp;maxEdgeLength, double &amp;minFaceArea, double &amp;meanFaceArea, double &amp;medianFaceArea, double &amp;maxFaceArea)</td></tr>
<tr class="separator:a8aa1d0cd2ffbc8cff5bdfb1abe58cb11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db0b75590f1536188088497c4277230"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1MeshAlg.html#a1db0b75590f1536188088497c4277230">computeTangentSpaceBasis</a> (const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;vertexArray, const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector2.html">Vector2</a> &gt; &amp;texCoordArray, const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;vertexNormalArray, const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1MeshAlg_1_1Face.html">Face</a> &gt; &amp;faceArray, <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;tangent, <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;binormal)</td></tr>
<tr class="separator:a1db0b75590f1536188088497c4277230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c9a8a2730418ab9aef5e8765fa57fc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1MeshAlg.html#a61c9a8a2730418ab9aef5e8765fa57fc">computeNormals</a> (const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;vertexArray, const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1MeshAlg_1_1Face.html">Face</a> &gt; &amp;faceArray, const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; int &gt; &gt; &amp;adjacentFaceArray, <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;vertexNormalArray, <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;faceNormalArray)</td></tr>
<tr class="separator:a61c9a8a2730418ab9aef5e8765fa57fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720141b763de04cad91c2331f8f6ff22"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1MeshAlg.html#a720141b763de04cad91c2331f8f6ff22">computeNormals</a> (const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;vertexGeometry, const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1MeshAlg_1_1Face.html">Face</a> &gt; &amp;faceArray, const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1MeshAlg_1_1Vertex.html">Vertex</a> &gt; &amp;vertexArray, <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;vertexNormalArray, <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;faceNormalArray)</td></tr>
<tr class="separator:a720141b763de04cad91c2331f8f6ff22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e63563e941c28782bda25c0a7be48ec"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1MeshAlg.html#a2e63563e941c28782bda25c0a7be48ec">computeNormals</a> (<a class="el" href="classG3D_1_1MeshAlg_1_1Geometry.html">Geometry</a> &amp;geometry, const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; int &gt; &amp;indexArray)</td></tr>
<tr class="separator:a2e63563e941c28782bda25c0a7be48ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06eeca837dae119e80477a902d0a6e92"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1MeshAlg.html#a06eeca837dae119e80477a902d0a6e92">computeFaceNormals</a> (const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;vertexArray, const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1MeshAlg_1_1Face.html">Face</a> &gt; &amp;faceArray, <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;faceNormals, bool normalize=true)</td></tr>
<tr class="separator:a06eeca837dae119e80477a902d0a6e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96e5d6a6ebb7d11a8627f46ca54df09"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1MeshAlg.html#ac96e5d6a6ebb7d11a8627f46ca54df09">identifyBackfaces</a> (const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;vertexArray, const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1MeshAlg_1_1Face.html">Face</a> &gt; &amp;faceArray, const <a class="el" href="classG3D_1_1Vector4.html">Vector4</a> &amp;P, <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; bool &gt; &amp;backface)</td></tr>
<tr class="separator:ac96e5d6a6ebb7d11a8627f46ca54df09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e08fb418c4c5583a99f71f6fa41f786"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1MeshAlg.html#a3e08fb418c4c5583a99f71f6fa41f786">identifyBackfaces</a> (const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;vertexArray, const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1MeshAlg_1_1Face.html">Face</a> &gt; &amp;faceArray, const <a class="el" href="classG3D_1_1Vector4.html">Vector4</a> &amp;P, <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; bool &gt; &amp;backface, const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;faceNormals)</td></tr>
<tr class="separator:a3e08fb418c4c5583a99f71f6fa41f786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2526826faf16c087a1df2ce200c01f90"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1MeshAlg.html#a2526826faf16c087a1df2ce200c01f90">computeWeld</a> (const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;oldVertexPositions, <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;newVertexPositions, <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; int &gt; &amp;toNew, <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; int &gt; &amp;toOld, double radius=fuzzyEpsilon)</td></tr>
<tr class="separator:a2526826faf16c087a1df2ce200c01f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8404724d03c8640776d4431d1f52991f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1MeshAlg.html#a8404724d03c8640776d4431d1f52991f">weldAdjacency</a> (const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;originalGeometry, <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1MeshAlg_1_1Face.html">Face</a> &gt; &amp;faceArray, <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1MeshAlg_1_1Edge.html">Edge</a> &gt; &amp;edgeArray, <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1MeshAlg_1_1Vertex.html">Vertex</a> &gt; &amp;vertexArray, double radius=fuzzyEpsilon)</td></tr>
<tr class="separator:a8404724d03c8640776d4431d1f52991f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46b88f28d1f1c46687e1f16684c9775"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1MeshAlg.html#aa46b88f28d1f1c46687e1f16684c9775">countBoundaryEdges</a> (const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1MeshAlg_1_1Edge.html">Edge</a> &gt; &amp;edgeArray)</td></tr>
<tr class="separator:aa46b88f28d1f1c46687e1f16684c9775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4735cbbb41b5853d132eb79b669fb25c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1MeshAlg.html#a4735cbbb41b5853d132eb79b669fb25c">createIndexArray</a> (int n, <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; int &gt; &amp;array, int start=0, int run=1, int skip=0)</td></tr>
<tr class="separator:a4735cbbb41b5853d132eb79b669fb25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8005e27b8d9d5abf999316ba72cd5003"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1MeshAlg.html#a8005e27b8d9d5abf999316ba72cd5003">computeBounds</a> (const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;vertex, class <a class="el" href="classG3D_1_1AABox.html">AABox</a> &amp;box, class <a class="el" href="classG3D_1_1Sphere.html">Sphere</a> &amp;sphere)</td></tr>
<tr class="separator:a8005e27b8d9d5abf999316ba72cd5003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4bc1f01025c50ed2ad9a9a21dd3f87"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1MeshAlg.html#a9a4bc1f01025c50ed2ad9a9a21dd3f87">computeBounds</a> (const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;vertex, const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; int &gt; &amp;index, class <a class="el" href="classG3D_1_1AABox.html">AABox</a> &amp;box, class <a class="el" href="classG3D_1_1Sphere.html">Sphere</a> &amp;sphere)</td></tr>
<tr class="separator:a9a4bc1f01025c50ed2ad9a9a21dd3f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956296535f61f5f3411174b1d97deba1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1MeshAlg.html#a956296535f61f5f3411174b1d97deba1">debugCheckConsistency</a> (const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1MeshAlg_1_1Face.html">Face</a> &gt; &amp;faceArray, const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1MeshAlg_1_1Edge.html">Edge</a> &gt; &amp;edgeArray, const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1MeshAlg_1_1Vertex.html">Vertex</a> &gt; &amp;vertexArray)</td></tr>
<tr class="separator:a956296535f61f5f3411174b1d97deba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca5a2c30e87ac6c0d5b15c79e81dd5a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1MeshAlg.html#a8ca5a2c30e87ac6c0d5b15c79e81dd5a">generateGrid</a> (<a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;vertex, <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector2.html">Vector2</a> &gt; &amp;texCoord, <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; int &gt; &amp;index, int wCells=10, int hCells=10, const <a class="el" href="classG3D_1_1Vector2.html">Vector2</a> &amp;textureScale=<a class="el" href="classG3D_1_1Vector2.html">Vector2</a>(1, 1), bool spaceCentered=true, bool twoSided=true, const <a class="el" href="classG3D_1_1CoordinateFrame.html">CoordinateFrame</a> &amp;xform=<a class="el" href="classG3D_1_1CoordinateFrame.html">CoordinateFrame</a>(), const <a class="el" href="classG3D_1_1ReferenceCountedPointer.html">Image1::Ref</a> &amp;elevation=NULL)</td></tr>
<tr class="separator:a8ca5a2c30e87ac6c0d5b15c79e81dd5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc9b8ecc53935df67b76bb2d6ce2eb2"><td class="memTemplParams" colspan="2">template&lt;class IndexType &gt; </td></tr>
<tr class="memitem:a8dc9b8ecc53935df67b76bb2d6ce2eb2"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classG3D_1_1MeshAlg.html#a8dc9b8ecc53935df67b76bb2d6ce2eb2">toIndexedTriList</a> (const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; IndexType &gt; &amp;inIndices, <a class="el" href="classG3D_1_1MeshAlg.html#a764b82b69eb915de51242b58f9eeb615">MeshAlg::Primitive</a> inType, <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; IndexType &gt; &amp;outIndices)</td></tr>
<tr class="separator:a8dc9b8ecc53935df67b76bb2d6ce2eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:ae0cac2603ebeaace79d19a7d46d8fa10"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1MeshAlg.html#ae0cac2603ebeaace79d19a7d46d8fa10">findEdgeIndex</a> (const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;vertexArray, <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1MeshAlg_1_1Edge.html">Edge</a> &gt; &amp;geometricEdgeArray, int i0, int i1, int f, double area)</td></tr>
<tr class="separator:ae0cac2603ebeaace79d19a7d46d8fa10"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Indexed <b>mesh alg</b>orithms. You have to build your own mesh class. </p>
<p>No mesh class is provided with G3D because there isn't an "ideal" mesh format&ndash; one application needs keyframed animation, another skeletal animation, a third texture coordinates, a fourth cannot precompute information, etc. Instead of compromising, this class implements the hard parts of mesh computation and you can write your own ideal mesh class on top of it.</p>
<dl class="section see"><dt>See also</dt><dd>G3D::ArticulatedModel, G3D::IFSModel </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a764b82b69eb915de51242b58f9eeb615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a764b82b69eb915de51242b58f9eeb615">&#9670;&nbsp;</a></span>Primitive</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classG3D_1_1PrimitiveType.html">PrimitiveType</a> <a class="el" href="classG3D_1_1MeshAlg.html#a764b82b69eb915de51242b58f9eeb615">G3D::MeshAlg::Primitive</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000017">Deprecated:</a></b></dt><dd></dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af9c7e0c436b7ea572b49c138e66fe1e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9c7e0c436b7ea572b49c138e66fe1e1">&#9670;&nbsp;</a></span>computeAdjacency() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void G3D::MeshAlg::computeAdjacency </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertexGeometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indexArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1MeshAlg_1_1Face.html">Face</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>faceArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1MeshAlg_1_1Edge.html">Edge</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edgeArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1MeshAlg_1_1Vertex.html">Vertex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertexArray</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a set of vertices and a set of indices for traversing them to create triangles, computes other mesh properties. <br />
 <b>Colocated vertices are treated as separate.</b> To have colocated vertices collapsed (necessary for many algorithms, like shadowing), weld the mesh before computing adjacency.</p>
<p><em>Recent change: In version 6.00, colocated vertices were automatically welded by this routine and degenerate faces and edges were removed. That is no longer the case.</em></p>
<p>Where two faces meet, there are two opposite directed edges. These are collapsed into a single bidirectional edge in the edgeArray. If four faces meet exactly at the same edge, that edge will appear twice in the array, and so on. If an edge is a boundary of the mesh (i.e. if the edge has only one adjacent face) it will appear in the array with one face index set to <a class="el" href="classG3D_1_1MeshAlg_1_1Face.html#a62bb5fc1d62ce650c721e4c540856537">MeshAlg::Face::NONE</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexGeometry</td><td>Vertex positions to use when deciding colocation. </td></tr>
    <tr><td class="paramname">indexArray</td><td>Order to traverse vertices to make triangles </td></tr>
    <tr><td class="paramname">faceArray</td><td><em>Output</em> </td></tr>
    <tr><td class="paramname">edgeArray</td><td><em>Output</em>. Sorted so that boundary edges are at the end of the array. </td></tr>
    <tr><td class="paramname">vertexArray</td><td><em>Output</em> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7523393a6241ffdccc3e40485e4688ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7523393a6241ffdccc3e40485e4688ad">&#9670;&nbsp;</a></span>computeAdjacency() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void G3D::MeshAlg::computeAdjacency </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertexArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indexArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1MeshAlg_1_1Face.html">Face</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>faceArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1MeshAlg_1_1Edge.html">Edge</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edgeArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>facesAdjacentToVertex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000018">Deprecated:</a></b></dt><dd>Use the other version of computeAdjacency, which takes Array&lt;Vertex&gt;. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">facesAdjacentToVertex</td><td><em>Output</em> adjacentFaceArray[v] is an array of indices for faces touching vertex index v </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8aa1d0cd2ffbc8cff5bdfb1abe58cb11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aa1d0cd2ffbc8cff5bdfb1abe58cb11">&#9670;&nbsp;</a></span>computeAreaStatistics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void G3D::MeshAlg::computeAreaStatistics </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertexArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indexArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>minEdgeLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>meanEdgeLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>medianEdgeLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>maxEdgeLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>minFaceArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>meanFaceArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>medianFaceArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>maxFaceArea</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes some basic mesh statistics including: min, max mean and median, edge lengths; and min, mean, median, and max face area.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexArray</td><td>Vertex positions to use when deciding colocation. </td></tr>
    <tr><td class="paramname">indexArray</td><td>Order to traverse vertices to make triangles </td></tr>
    <tr><td class="paramname">minEdgeLength</td><td>Minimum edge length </td></tr>
    <tr><td class="paramname">meanEdgeLength</td><td>Mean edge length </td></tr>
    <tr><td class="paramname">medianEdgeLength</td><td>Median edge length </td></tr>
    <tr><td class="paramname">maxEdgeLength</td><td>Max edge length </td></tr>
    <tr><td class="paramname">minFaceArea</td><td>Minimum face area </td></tr>
    <tr><td class="paramname">meanFaceArea</td><td>Mean face area </td></tr>
    <tr><td class="paramname">medianFaceArea</td><td>Median face area </td></tr>
    <tr><td class="paramname">maxFaceArea</td><td>Max face area </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8005e27b8d9d5abf999316ba72cd5003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8005e27b8d9d5abf999316ba72cd5003">&#9670;&nbsp;</a></span>computeBounds() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void G3D::MeshAlg::computeBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="classG3D_1_1AABox.html">AABox</a> &amp;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="classG3D_1_1Sphere.html">Sphere</a> &amp;&#160;</td>
          <td class="paramname"><em>sphere</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes a conservative, near-optimal axis aligned bounding box and sphere.</p>
<p><b>[The]</b> bounding sphere uses the method from J. Ritter. An effcient bounding sphere. In Andrew S. Glassner, editor, Graphics Gems. Academic Press, Boston, MA, 1990. </p>

</div>
</div>
<a id="a9a4bc1f01025c50ed2ad9a9a21dd3f87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a4bc1f01025c50ed2ad9a9a21dd3f87">&#9670;&nbsp;</a></span>computeBounds() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void G3D::MeshAlg::computeBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="classG3D_1_1AABox.html">AABox</a> &amp;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="classG3D_1_1Sphere.html">Sphere</a> &amp;&#160;</td>
          <td class="paramname"><em>sphere</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes bounds for a subset of the vertices. It is ok if vertices appear more than once in the index array. </p>

</div>
</div>
<a id="a06eeca837dae119e80477a902d0a6e92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06eeca837dae119e80477a902d0a6e92">&#9670;&nbsp;</a></span>computeFaceNormals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void G3D::MeshAlg::computeFaceNormals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertexArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1MeshAlg_1_1Face.html">Face</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>faceArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>faceNormals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes face normals only. Significantly faster (especially if normalize is false) than computeNormals. </p><dl class="section see"><dt>See also</dt><dd>weld </dd></dl>

</div>
</div>
<a id="a61c9a8a2730418ab9aef5e8765fa57fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61c9a8a2730418ab9aef5e8765fa57fc">&#9670;&nbsp;</a></span>computeNormals() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void G3D::MeshAlg::computeNormals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertexArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1MeshAlg_1_1Face.html">Face</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>faceArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>adjacentFaceArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertexNormalArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>faceNormalArray</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000019">Deprecated:</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="a720141b763de04cad91c2331f8f6ff22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a720141b763de04cad91c2331f8f6ff22">&#9670;&nbsp;</a></span>computeNormals() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void G3D::MeshAlg::computeNormals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertexGeometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1MeshAlg_1_1Face.html">Face</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>faceArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1MeshAlg_1_1Vertex.html">Vertex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertexArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertexNormalArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>faceNormalArray</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classG3D_1_1MeshAlg_1_1Vertex.html">Vertex</a> normals are weighted by the area of adjacent faces. Nelson Max showed this is superior to uniform weighting for general meshes in jgt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexNormalArray</td><td>Output. <a class="el" href="classUnit.html">Unit</a> length </td></tr>
    <tr><td class="paramname">faceNormalArray</td><td>Output. Degenerate faces produce zero magnitude normals. <a class="el" href="classUnit.html">Unit</a> length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>weld </dd></dl>

</div>
</div>
<a id="a2e63563e941c28782bda25c0a7be48ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e63563e941c28782bda25c0a7be48ec">&#9670;&nbsp;</a></span>computeNormals() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void G3D::MeshAlg::computeNormals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classG3D_1_1MeshAlg_1_1Geometry.html">Geometry</a> &amp;&#160;</td>
          <td class="paramname"><em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indexArray</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes unit length normals in place using the other computeNormals methods. If you already have a face array use another method; it will be faster. </p><dl class="section see"><dt>See also</dt><dd>weld </dd></dl>

</div>
</div>
<a id="a1db0b75590f1536188088497c4277230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db0b75590f1536188088497c4277230">&#9670;&nbsp;</a></span>computeTangentSpaceBasis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void G3D::MeshAlg::computeTangentSpaceBasis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertexArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector2.html">Vector2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texCoordArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertexNormalArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1MeshAlg_1_1Face.html">Face</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>faceArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tangent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>binormal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes tangent and binormal vectors, which provide a (mostly) consistent parameterization over the surface for effects like bump mapping. In the resulting coordinate frame, T = x (varies with texture s coordinate), B = y (varies with negative texture t coordinate), and N = z for a right-handed coordinate frame. If a billboard is vertical on the screen in view of the camera, the tangent space matches the camera's coordinate frame.</p>
<p>The vertex, texCoord, tangent, and binormal arrays are parallel arrays.</p>
<p>The resulting tangent and binormal might not be exactly perpendicular to each other. They are guaranteed to be perpendicular to the normal.</p>
<p><b>[Max]</b> McGuire </p>

</div>
</div>
<a id="a2526826faf16c087a1df2ce200c01f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2526826faf16c087a1df2ce200c01f90">&#9670;&nbsp;</a></span>computeWeld()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void G3D::MeshAlg::computeWeld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>oldVertexPositions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>newVertexPositions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3D_1_1Array.html">Array</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>toNew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3D_1_1Array.html">Array</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>toOld</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em> = <code>fuzzyEpsilon</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Welds nearby and colocated elements of the <em>oldVertexArray</em> together so that <em>newVertexArray</em> contains no vertices within <em>radius</em> of one another. Every vertex in newVertexPositions also appears in oldVertexPositions. This is useful for downsampling meshes and welding cracks created by artist errors or numerical imprecision. <br />
 The two integer arrays map indices back and forth between the arrays according to: </p><pre>
oldVertexArray[toOld[ni]] == newVertexArray[ni]
oldVertexArray[oi] == newVertexArray[toNew[ni]]
</pre><p>Note that newVertexPositions is never longer than oldVertexPositions and is shorter when vertices are welded.</p>
<p>Welding with a large radius will effectively compute a lower level of detail for the mesh.</p>
<p>The welding method runs in roughly linear time in the length of oldVertexArray&ndash; a uniform spatial grid is used to achieve nearly constant time vertex collapses for uniformly distributed vertices.</p>
<p>It is sometimes desirable to keep the original vertex ordering but identify the unique vertices. The following code computes array canonical s.t. canonical[v] = first occurance of a vertex near oldVertexPositions[v] in oldVertexPositions.</p>
<pre>
   <a class="el" href="classG3D_1_1Array.html">Array&lt;int&gt;</a> canonical(oldVertexPositions.size()), toNew, toOld;
   computeWeld(oldVertexPositions, Array&lt;Vector3&gt;(), toNew, toOld, radius);
   for (int v = 0; v &lt; canonical.size(); ++v) {
       canonical[v] = toOld[toNew[v]];
   }
</pre><p>See also <a class="el" href="classG3D_1_1MeshAlg.html#a8404724d03c8640776d4431d1f52991f">G3D::MeshAlg::weldAdjacency</a>.</p>
<p><b>[The]</b> method is that described as the 'Grouper' in Baum, Mann, Smith, and Winget, Making Radiosity Usable: Automatic Preprocessing and Meshing Techniques for the Generation of Accurate Radiosity Solutions, Computer Graphics vol 25, no 4, July 1991.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000020">Deprecated:</a></b></dt><dd>Use weld. </dd></dl>

</div>
</div>
<a id="aa46b88f28d1f1c46687e1f16684c9775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa46b88f28d1f1c46687e1f16684c9775">&#9670;&nbsp;</a></span>countBoundaryEdges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int G3D::MeshAlg::countBoundaryEdges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1MeshAlg_1_1Edge.html">Edge</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edgeArray</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Counts the number of edges (in an edge array returned from <a class="el" href="classG3D_1_1MeshAlg.html#af9c7e0c436b7ea572b49c138e66fe1e1">MeshAlg::computeAdjacency</a>) that have only one adjacent face. </p>

</div>
</div>
<a id="a4735cbbb41b5853d132eb79b669fb25c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4735cbbb41b5853d132eb79b669fb25c">&#9670;&nbsp;</a></span>createIndexArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void G3D::MeshAlg::createIndexArray </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3D_1_1Array.html">Array</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>run</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>skip</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generates an array of integers from start to start + n - 1 that have run numbers in series then omit the next skip before the next run. Useful for turning a triangle list into an indexed face set.</p>
<p>Example: </p><pre>
  createIndexArray(10, x);
  // x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</pre><pre>  createIndexArray(5, x, 2);
  // x = [2, 3, 4, 5, 6, 7]</pre><pre>  createIndexArray(6, x, 0, 2, 1);
  // x = [0, 1, 3, 4, 6, 7]
</pre> 
</div>
</div>
<a id="a956296535f61f5f3411174b1d97deba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a956296535f61f5f3411174b1d97deba1">&#9670;&nbsp;</a></span>debugCheckConsistency()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void G3D::MeshAlg::debugCheckConsistency </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1MeshAlg_1_1Face.html">Face</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>faceArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1MeshAlg_1_1Edge.html">Edge</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edgeArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1MeshAlg_1_1Vertex.html">Vertex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertexArray</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>In debug mode, asserts that the adjacency references between the face, edge, and vertex array are consistent. </p>

</div>
</div>
<a id="ae0cac2603ebeaace79d19a7d46d8fa10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0cac2603ebeaace79d19a7d46d8fa10">&#9670;&nbsp;</a></span>findEdgeIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int G3D::MeshAlg::findEdgeIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertexArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1MeshAlg_1_1Edge.html">Edge</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>geometricEdgeArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>area</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper for computeAdjacency. If a directed edge with index e already exists from i0 to i1 then e is returned. If a directed edge with index e already exists from i1 to i0, ~e is returned (the complement) and edgeArray[e] is set to f. Otherwise, a new edge is created from i0 to i1 with first face index f and its index is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexArray</td><td><a class="el" href="classG3D_1_1MeshAlg_1_1Vertex.html">Vertex</a> positions to use when deciding colocation.</td></tr>
    <tr><td class="paramname">area</td><td>Area of face f. When multiple edges of the same direction are found between the same vertices (usually because of degenerate edges) the face with larger area is kept in the edge table. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ca5a2c30e87ac6c0d5b15c79e81dd5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ca5a2c30e87ac6c0d5b15c79e81dd5a">&#9670;&nbsp;</a></span>generateGrid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void G3D::MeshAlg::generateGrid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector2.html">Vector2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texCoord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3D_1_1Array.html">Array</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>wCells</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>hCells</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Vector2.html">Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>textureScale</em> = <code><a class="el" href="classG3D_1_1Vector2.html">Vector2</a>(1,1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>spaceCentered</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>twoSided</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1CoordinateFrame.html">CoordinateFrame</a> &amp;&#160;</td>
          <td class="paramname"><em>xform</em> = <code><a class="el" href="classG3D_1_1CoordinateFrame.html">CoordinateFrame</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1ReferenceCountedPointer.html">Image1::Ref</a> &amp;&#160;</td>
          <td class="paramname"><em>elevation</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generates a unit square in the X-Z plane composed of a grid of wCells x hCells squares and then transforms it by xform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex</td><td>Output vertices </td></tr>
    <tr><td class="paramname">texCoord</td><td>Output texture coordinates </td></tr>
    <tr><td class="paramname">index</td><td>Output triangle list indices </td></tr>
    <tr><td class="paramname">textureScale</td><td>Lower-right texture coordinate </td></tr>
    <tr><td class="paramname">spaceCentered</td><td>If true, the coordinates generated are centered at the origin before the transformation. </td></tr>
    <tr><td class="paramname">twoSided</td><td>If true, matching top and bottom planes are generated. </td></tr>
    <tr><td class="paramname">elevation</td><td>If non-NULL, values from this image are used as elevations. Apply an <em>xform</em> to adjust the scale </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac96e5d6a6ebb7d11a8627f46ca54df09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac96e5d6a6ebb7d11a8627f46ca54df09">&#9670;&nbsp;</a></span>identifyBackfaces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void G3D::MeshAlg::identifyBackfaces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertexArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1MeshAlg_1_1Face.html">Face</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>faceArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3D_1_1Array.html">Array</a>&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>backface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Classifies each face as a backface or a front face relative to the observer point P (which is at infinity when P.w = 0). A face with normal exactly perpendicular to the observer vector may be classified as either a front or a back face arbitrarily. </p>

</div>
</div>
<a id="a3e08fb418c4c5583a99f71f6fa41f786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e08fb418c4c5583a99f71f6fa41f786">&#9670;&nbsp;</a></span>identifyBackfaces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void G3D::MeshAlg::identifyBackfaces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertexArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1MeshAlg_1_1Face.html">Face</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>faceArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3D_1_1Array.html">Array</a>&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>backface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>faceNormals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A faster version of identifyBackfaces for the case where face normals have already been computed </p>

</div>
</div>
<a id="a8dc9b8ecc53935df67b76bb2d6ce2eb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dc9b8ecc53935df67b76bb2d6ce2eb2">&#9670;&nbsp;</a></span>toIndexedTriList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IndexType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void G3D::MeshAlg::toIndexedTriList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; IndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>inIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3D_1_1MeshAlg.html#a764b82b69eb915de51242b58f9eeb615">MeshAlg::Primitive</a>&#160;</td>
          <td class="paramname"><em>inType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3D_1_1Array.html">Array</a>&lt; IndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>outIndices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts quadlist (QUADS), triangle fan (TRIANGLE_FAN), tristrip(TRIANGLE_STRIP), and quadstrip (QUAD_STRIP) indices into triangle list (TRIANGLES) indices and appends them to outIndices. </p>

</div>
</div>
<a id="a8404724d03c8640776d4431d1f52991f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8404724d03c8640776d4431d1f52991f">&#9670;&nbsp;</a></span>weldAdjacency()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void G3D::MeshAlg::weldAdjacency </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Vector3.html">Vector3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>originalGeometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1MeshAlg_1_1Face.html">Face</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>faceArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1MeshAlg_1_1Edge.html">Edge</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edgeArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1MeshAlg_1_1Vertex.html">Vertex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertexArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em> = <code>fuzzyEpsilon</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Modifies the face, edge, and vertex arrays in place so that colocated (within radius) vertices are treated as identical. Note that the vertexArray and corresponding geometry will contain elements that are no longer used. In the vertexArray, these elements are initialized to MeshAlg::Vertex() but not removed (because removal would change the indexing).</p>
<p>This is a good preprocessing step for algorithms that are only concerned with the shape of a mesh (e.g. cartoon rendering, fur, shadows) and not the indexing of the vertices.</p>
<p>Use this method when you have already computed adjacency information and want to collapse colocated vertices within that data without disturbing the actual mesh vertices or indexing scheme. <br />
 If you have not computed adjacency already, use <a class="el" href="classG3D_1_1MeshAlg.html#a2526826faf16c087a1df2ce200c01f90">MeshAlg::computeWeld</a> instead and compute adjacency information after welding.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000021">Deprecated:</a></b></dt><dd>Use weld.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">faceArray</td><td>Mutated in place. Size is maintained (degenerate faces are <b>not</b> removed). </td></tr>
    <tr><td class="paramname">edgeArray</td><td>Mutated in place. May shrink if boundary edges are welded together. </td></tr>
    <tr><td class="paramname">vertexArray</td><td>Mutated in place. Size is maintained (duplicate vertices contain no adjacency info). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>dep/include/g3dlite/G3D/<a class="el" href="MeshAlg_8h_source.html">MeshAlg.h</a></li>
<li>dep/src/g3dlite/<a class="el" href="MeshAlg_8cpp.html">MeshAlg.cpp</a></li>
<li>dep/src/g3dlite/<a class="el" href="MeshAlgAdjacency_8cpp.html">MeshAlgAdjacency.cpp</a></li>
<li>dep/src/g3dlite/<a class="el" href="MeshAlgWeld_8cpp.html">MeshAlgWeld.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
