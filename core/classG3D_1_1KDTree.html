<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>blizzlike core: G3D::KDTree&lt; T, BoundsFunc, HashFunc, EqualsFunc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">blizzlike core
   </div>
   <div id="projectbrief">mmorpg server</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>G3D</b></li><li class="navelem"><a class="el" href="classG3D_1_1KDTree.html">KDTree</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classG3D_1_1KDTree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">G3D::KDTree&lt; T, BoundsFunc, HashFunc, EqualsFunc &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="KDTree_8h_source.html">KDTree.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1KDTree_1_1BoundsComparator.html">BoundsComparator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1KDTree_1_1BoxIntersectionIterator.html">BoxIntersectionIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1KDTree_1_1CenterComparator.html">CenterComparator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1KDTree_1_1Comparator.html">Comparator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1KDTree_1_1Handle.html">Handle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1KDTree_1_1Iterator.html">Iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1KDTree_1_1Node.html">Node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a07702707d8efe310b9f875f8504602b7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1KDTree.html#a07702707d8efe310b9f875f8504602b7">KDTree</a> ()</td></tr>
<tr class="separator:a07702707d8efe310b9f875f8504602b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae4af256cae6ad4f108ea07e708a2c7"><td class="memItemLeft" align="right" valign="top"><a id="adae4af256cae6ad4f108ea07e708a2c7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>KDTree</b> (const <a class="el" href="classG3D_1_1KDTree.html">KDTree</a> &amp;src)</td></tr>
<tr class="separator:adae4af256cae6ad4f108ea07e708a2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5518e47ca7601da3bec6f315619d636"><td class="memItemLeft" align="right" valign="top"><a id="af5518e47ca7601da3bec6f315619d636"></a>
<a class="el" href="classG3D_1_1KDTree.html">KDTree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classG3D_1_1KDTree.html">KDTree</a> &amp;src)</td></tr>
<tr class="separator:af5518e47ca7601da3bec6f315619d636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a88cf5fd2d63c455d9b678a2a9bb68f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1KDTree.html#a9a88cf5fd2d63c455d9b678a2a9bb68f">clear</a> ()</td></tr>
<tr class="separator:a9a88cf5fd2d63c455d9b678a2a9bb68f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25935326d2cdae631433c7b72b0d7b98"><td class="memItemLeft" align="right" valign="top"><a id="a25935326d2cdae631433c7b72b0d7b98"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const</td></tr>
<tr class="separator:a25935326d2cdae631433c7b72b0d7b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123584d0d7b24cae03644e35249892d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1KDTree.html#a123584d0d7b24cae03644e35249892d3">insert</a> (const T &amp;value)</td></tr>
<tr class="separator:a123584d0d7b24cae03644e35249892d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b199944ac538cd1ee751868f8bc28d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1KDTree.html#a21b199944ac538cd1ee751868f8bc28d">insert</a> (const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; T &gt; &amp;valueArray)</td></tr>
<tr class="separator:a21b199944ac538cd1ee751868f8bc28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f5deec7e4dcb90c8d133001d6c801a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1KDTree.html#a28f5deec7e4dcb90c8d133001d6c801a">contains</a> (const T &amp;value)</td></tr>
<tr class="separator:a28f5deec7e4dcb90c8d133001d6c801a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739c5a93a109f2108be49935f6699e62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1KDTree.html#a739c5a93a109f2108be49935f6699e62">remove</a> (const T &amp;value)</td></tr>
<tr class="separator:a739c5a93a109f2108be49935f6699e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6717d5d15e096cb53af03b88050b116e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1KDTree.html#a6717d5d15e096cb53af03b88050b116e">update</a> (const T &amp;value)</td></tr>
<tr class="separator:a6717d5d15e096cb53af03b88050b116e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f642ca5c6e954a88569889cfb337dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1KDTree.html#af5f642ca5c6e954a88569889cfb337dd">balance</a> (int valuesPerNode=5, int numMeanSplits=3)</td></tr>
<tr class="separator:af5f642ca5c6e954a88569889cfb337dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63839bda2d6dbfb182ab9c9e927b3d2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1KDTree.html#a63839bda2d6dbfb182ab9c9e927b3d2d">setContents</a> (const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; T &gt; &amp;array, int valuesPerNode=5, int numMeanSplits=3)</td></tr>
<tr class="separator:a63839bda2d6dbfb182ab9c9e927b3d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1718bd49f69fa1a96a01232db2c9e84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1KDTree.html#aa1718bd49f69fa1a96a01232db2c9e84">getIntersectingMembers</a> (const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Plane.html">Plane</a> &gt; &amp;plane, <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; T *&gt; &amp;members) const</td></tr>
<tr class="separator:aa1718bd49f69fa1a96a01232db2c9e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7499f19564782b57eec545f9226c49c1"><td class="memItemLeft" align="right" valign="top"><a id="a7499f19564782b57eec545f9226c49c1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>getIntersectingMembers</b> (const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Plane.html">Plane</a> &gt; &amp;plane, <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; T &gt; &amp;members) const</td></tr>
<tr class="separator:a7499f19564782b57eec545f9226c49c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2a4cda2ef51a23db37da7b7b96824e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1KDTree.html#a3c2a4cda2ef51a23db37da7b7b96824e">getIntersectingMembers</a> (const <a class="el" href="classG3D_1_1GCamera_1_1Frustum.html">GCamera::Frustum</a> &amp;frustum, <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; T *&gt; &amp;members) const</td></tr>
<tr class="separator:a3c2a4cda2ef51a23db37da7b7b96824e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8b3f1656693089e42db2df56299314"><td class="memItemLeft" align="right" valign="top"><a id="a6b8b3f1656693089e42db2df56299314"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>getIntersectingMembers</b> (const <a class="el" href="classG3D_1_1GCamera_1_1Frustum.html">GCamera::Frustum</a> &amp;frustum, <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; T &gt; &amp;members) const</td></tr>
<tr class="separator:a6b8b3f1656693089e42db2df56299314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a36506242afbf40fe40a76df8e0296"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classG3D_1_1KDTree_1_1BoxIntersectionIterator.html">BoxIntersectionIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1KDTree.html#a38a36506242afbf40fe40a76df8e0296">beginBoxIntersection</a> (const <a class="el" href="classG3D_1_1AABox.html">AABox</a> &amp;box) const</td></tr>
<tr class="separator:a38a36506242afbf40fe40a76df8e0296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84fad0b9b0071bb47e96763816b6cb89"><td class="memItemLeft" align="right" valign="top"><a id="a84fad0b9b0071bb47e96763816b6cb89"></a>
<a class="el" href="classG3D_1_1KDTree_1_1BoxIntersectionIterator.html">BoxIntersectionIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>endBoxIntersection</b> () const</td></tr>
<tr class="separator:a84fad0b9b0071bb47e96763816b6cb89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a3b4247b3c6f89b3c119a8d68df556"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1KDTree.html#a47a3b4247b3c6f89b3c119a8d68df556">getIntersectingMembers</a> (const <a class="el" href="classG3D_1_1AABox.html">AABox</a> &amp;box, <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; T *&gt; &amp;members) const</td></tr>
<tr class="separator:a47a3b4247b3c6f89b3c119a8d68df556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6c1be9925bfa7ceaea465240fd3ceb"><td class="memItemLeft" align="right" valign="top"><a id="adf6c1be9925bfa7ceaea465240fd3ceb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>getIntersectingMembers</b> (const <a class="el" href="classG3D_1_1AABox.html">AABox</a> &amp;box, <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; T &gt; &amp;members) const</td></tr>
<tr class="separator:adf6c1be9925bfa7ceaea465240fd3ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65fa03c5992256213ea9ec9d7a2c72f6"><td class="memTemplParams" colspan="2">template&lt;typename RayCallback &gt; </td></tr>
<tr class="memitem:a65fa03c5992256213ea9ec9d7a2c72f6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classG3D_1_1KDTree.html#a65fa03c5992256213ea9ec9d7a2c72f6">intersectRay</a> (const <a class="el" href="classG3D_1_1Ray.html">Ray</a> &amp;ray, RayCallback &amp;intersectCallback, float &amp;distance, bool intersectCallbackIsFast=false) const</td></tr>
<tr class="separator:a65fa03c5992256213ea9ec9d7a2c72f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a5f5fd6837107654019345828e4e70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1KDTree.html#a91a5f5fd6837107654019345828e4e70">getIntersectingMembers</a> (const <a class="el" href="classG3D_1_1Sphere.html">Sphere</a> &amp;sphere, <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; T *&gt; &amp;members) const</td></tr>
<tr class="memdesc:a91a5f5fd6837107654019345828e4e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all members whose bounding boxes intersect the sphere. The actual elements may not intersect the sphere.  <a href="#a91a5f5fd6837107654019345828e4e70">More...</a><br /></td></tr>
<tr class="separator:a91a5f5fd6837107654019345828e4e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fee86c51f113a82fc6a2d9e9dfdd400"><td class="memItemLeft" align="right" valign="top"><a id="a1fee86c51f113a82fc6a2d9e9dfdd400"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>getIntersectingMembers</b> (const <a class="el" href="classG3D_1_1Sphere.html">Sphere</a> &amp;sphere, <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; T &gt; &amp;members) const</td></tr>
<tr class="separator:a1fee86c51f113a82fc6a2d9e9dfdd400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa272a2ca9c758a603732e9197c3c25ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1KDTree.html#aa272a2ca9c758a603732e9197c3c25ba">serializeStructure</a> (<a class="el" href="classG3D_1_1BinaryOutput.html">BinaryOutput</a> &amp;bo) const</td></tr>
<tr class="separator:aa272a2ca9c758a603732e9197c3c25ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82766e1ef20fc4b8846fcee66ca2081d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1KDTree.html#a82766e1ef20fc4b8846fcee66ca2081d">deserializeStructure</a> (<a class="el" href="classG3D_1_1BinaryInput.html">BinaryInput</a> &amp;bi)</td></tr>
<tr class="separator:a82766e1ef20fc4b8846fcee66ca2081d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e49dffef19b6ef687f6a277f2314ca6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1KDTree.html#a4e49dffef19b6ef687f6a277f2314ca6">getMembers</a> (<a class="el" href="classG3D_1_1Array.html">Array</a>&lt; T &gt; &amp;members) const</td></tr>
<tr class="separator:a4e49dffef19b6ef687f6a277f2314ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857ab82721ac3e8b8f8bda2a3fd71157"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1KDTree.html#a857ab82721ac3e8b8f8bda2a3fd71157">getPointer</a> (const T &amp;value) const</td></tr>
<tr class="separator:a857ab82721ac3e8b8f8bda2a3fd71157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae7f0fa8924c0249a558b6e2d9921b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classG3D_1_1KDTree_1_1Iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1KDTree.html#a4ae7f0fa8924c0249a558b6e2d9921b1">begin</a> () const</td></tr>
<tr class="separator:a4ae7f0fa8924c0249a558b6e2d9921b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7d36dc8c68cd2db05fdd390e0520fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classG3D_1_1KDTree_1_1Iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1KDTree.html#afa7d36dc8c68cd2db05fdd390e0520fa">end</a> () const</td></tr>
<tr class="separator:afa7d36dc8c68cd2db05fdd390e0520fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a710825407c04856422a0f36584c70f70"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classG3D_1_1__internal_1_1Indirector.html">_internal::Indirector</a>&lt; <a class="el" href="classG3D_1_1KDTree_1_1Handle.html">Handle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1KDTree.html#a710825407c04856422a0f36584c70f70">Member</a></td></tr>
<tr class="separator:a710825407c04856422a0f36584c70f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f224ad193077bf522a70ecc2285ef93"><td class="memItemLeft" align="right" valign="top"><a id="a7f224ad193077bf522a70ecc2285ef93"></a>
typedef <a class="el" href="classG3D_1_1Table.html">Table</a>&lt; <a class="el" href="classG3D_1_1KDTree.html#a710825407c04856422a0f36584c70f70">Member</a>, <a class="el" href="classG3D_1_1KDTree_1_1Node.html">Node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MemberTable</b></td></tr>
<tr class="separator:a7f224ad193077bf522a70ecc2285ef93"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa0672440068e3a3b792c51a952b86c80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classG3D_1_1KDTree_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1KDTree.html#aa0672440068e3a3b792c51a952b86c80">makeNode</a> (<a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1KDTree_1_1Handle.html">Handle</a> *&gt; &amp;source, int valuesPerNode, int numMeanSplits, <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1KDTree_1_1Handle.html">Handle</a> *&gt; &amp;temp)</td></tr>
<tr class="separator:aa0672440068e3a3b792c51a952b86c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02b54babcac6503a5dfeb23ac8827368"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classG3D_1_1KDTree_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1KDTree.html#a02b54babcac6503a5dfeb23ac8827368">cloneTree</a> (<a class="el" href="classG3D_1_1KDTree_1_1Node.html">Node</a> *src)</td></tr>
<tr class="separator:a02b54babcac6503a5dfeb23ac8827368"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:aaa19e0e92163b06ec755a7ffb4ae57e4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classG3D_1_1AABox.html">AABox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1KDTree.html#aaa19e0e92163b06ec755a7ffb4ae57e4">computeBounds</a> (const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1KDTree_1_1Handle.html">Handle</a> *&gt; &amp;point, int beginIndex, int endIndex)</td></tr>
<tr class="separator:aaa19e0e92163b06ec755a7ffb4ae57e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d13c9b5240f8d2fa8fb398027006f4f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1KDTree.html#a1d13c9b5240f8d2fa8fb398027006f4f">getIntersectingMembers</a> (const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Plane.html">Plane</a> &gt; &amp;plane, <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; T *&gt; &amp;members, <a class="el" href="classG3D_1_1KDTree_1_1Node.html">Node</a> *node, uint32 parentMask)</td></tr>
<tr class="separator:a1d13c9b5240f8d2fa8fb398027006f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a8a35e683e0215aa3ca614babe498f7e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classG3D_1_1Table.html">MemberTable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1KDTree.html#a8a35e683e0215aa3ca614babe498f7e5">memberTable</a></td></tr>
<tr class="separator:a8a35e683e0215aa3ca614babe498f7e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05097a58f03f8f474cc8deb5cd14e57e"><td class="memItemLeft" align="right" valign="top"><a id="a05097a58f03f8f474cc8deb5cd14e57e"></a>
<a class="el" href="classG3D_1_1KDTree_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>root</b></td></tr>
<tr class="separator:a05097a58f03f8f474cc8deb5cd14e57e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, class BoundsFunc = BoundsTrait&lt;T&gt;, class HashFunc = HashTrait&lt;T&gt;, class EqualsFunc = EqualsTrait&lt;T&gt;&gt;<br />
class G3D::KDTree&lt; T, BoundsFunc, HashFunc, EqualsFunc &gt;</h3>

<p>A set that supports spatial queries using a KD tree (axis-aligned BSP tree) for speed.</p>
<p><a class="el" href="classG3D_1_1KDTree.html">KDTree</a> allows you to quickly find objects in 3D that lie within a box or along a ray. For large sets of objects it is much faster than testing each object for a collision.</p>
<p><a class="el" href="classG3D_1_1KDTree.html">KDTree</a> is as powerful as but more general than a Quad Tree, Oct Tree, or regular KD tree that cycles through axes, but less general than an unconstrained BSP tree (which is much slower to create).</p>
<p>Internally, objects are arranged into a tree according to their axis-aligned bounds. This increases the cost of insertion to O(log n) but allows fast overlap queries.</p>
<p><b>Template Parameters</b> </p>
<p>The template parameter <em>T</em> must be one for which the following functions are all overloaded:</p>
<pre>
 T::T(); // public constructor of no arguments
 template &lt;&gt; struct HashTrait&lt;T&gt; { static size_t hashCode(int key); };
 template&lt;&gt; struct BoundsTrait&lt;T&gt; { static void getBounds(const T&amp; obj, G3D::AABox&amp; out); };
</pre><p>G3D provides these for common classes like <a class="el" href="classG3D_1_1Vector3.html">G3D::Vector3</a> and <a class="el" href="classG3D_1_1Sphere.html">G3D::Sphere</a>. If you use a custom class, or a pointer to a custom class, you will need to define those functions.</p>
<p><b>Moving Set Members</b> </p>
<p>It is important that objects do not move without updating the <a class="el" href="classG3D_1_1KDTree.html">KDTree</a>. If the axis-aligned bounds of an object are about to change, <a class="el" href="classG3D_1_1KDTree.html#a739c5a93a109f2108be49935f6699e62">KDTree::remove</a> it before they change and <a class="el" href="classG3D_1_1KDTree.html#a123584d0d7b24cae03644e35249892d3">KDTree::insert</a> it again afterward. For objects where the hashCode and == operator are invariant with respect to the 3D position, you can use the <a class="el" href="classG3D_1_1KDTree.html#a6717d5d15e096cb53af03b88050b116e">KDTree::update</a> method as a shortcut to insert/remove an object in one step after it has moved.</p>
<p>Note: Do not mutate any value once it has been inserted into <a class="el" href="classG3D_1_1KDTree.html">KDTree</a>. Values are copied interally. All <a class="el" href="classG3D_1_1KDTree.html">KDTree</a> iterators convert to pointers to constant values to reinforce this.</p>
<p>If you want to mutate the objects you intend to store in a <a class="el" href="classG3D_1_1KDTree.html">KDTree</a> simply insert <em>pointers</em> to your objects instead of the objects themselves, and ensure that the above operations are defined. (And actually, because values are copied, if your values are large you may want to insert pointers anyway, to save space and make the balance operation faster.)</p>
<p><b>Dimensions</b> Although designed as a 3D-data structure, you can use the <a class="el" href="classG3D_1_1KDTree.html">KDTree</a> for data distributed along 2 or 1 axes by simply returning bounds that are always zero along one or more dimensions. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a710825407c04856422a0f36584c70f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a710825407c04856422a0f36584c70f70">&#9670;&nbsp;</a></span>Member</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class BoundsFunc  = BoundsTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classG3D_1_1__internal_1_1Indirector.html">_internal::Indirector</a>&lt;<a class="el" href="classG3D_1_1KDTree_1_1Handle.html">Handle</a>&gt; <a class="el" href="classG3D_1_1KDTree.html">G3D::KDTree</a>&lt; T, BoundsFunc, HashFunc, EqualsFunc &gt;::<a class="el" href="classG3D_1_1KDTree.html#a710825407c04856422a0f36584c70f70">Member</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Wrapper for a <a class="el" href="classG3D_1_1KDTree_1_1Handle.html">Handle</a>; used to create a memberTable that acts like Table&lt;Handle, Node*&gt; but stores only Handle* internally to avoid memory copies. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a07702707d8efe310b9f875f8504602b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07702707d8efe310b9f875f8504602b7">&#9670;&nbsp;</a></span>KDTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class BoundsFunc  = BoundsTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classG3D_1_1KDTree.html">G3D::KDTree</a>&lt; T, BoundsFunc, HashFunc, EqualsFunc &gt;::<a class="el" href="classG3D_1_1KDTree.html">KDTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>To construct a balanced tree, insert the elements and then call <a class="el" href="classG3D_1_1KDTree.html#af5f642ca5c6e954a88569889cfb337dd">KDTree::balance()</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af5f642ca5c6e954a88569889cfb337dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5f642ca5c6e954a88569889cfb337dd">&#9670;&nbsp;</a></span>balance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class BoundsFunc  = BoundsTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3D_1_1KDTree.html">G3D::KDTree</a>&lt; T, BoundsFunc, HashFunc, EqualsFunc &gt;::balance </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>valuesPerNode</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numMeanSplits</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Rebalances the tree (slow). Call when objects have moved substantially from their original positions (which unbalances the tree and causes the spatial queries to be slow).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuesPerNode</td><td>Maximum number of elements to put at a node.</td></tr>
    <tr><td class="paramname">numMeanSplits</td><td>numMeanSplits = 0 gives a fully axis aligned BSP-tree, where the balance operation attempts to balance the tree so that every splitting plane has an equal number of left and right children (i.e. it is a <b>median</b> split along that axis). <br />
This tends to maximize average performance. <br />
 You can override this behavior by setting a number of <b>mean</b> (average) splits. numMeanSplits = MAX_INT creates a full oct-tree, which tends to optimize peak performance at the expense of average performance. It tends to have better clustering behavior when members are not uniformly distributed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ae7f0fa8924c0249a558b6e2d9921b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ae7f0fa8924c0249a558b6e2d9921b1">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class BoundsFunc  = BoundsTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classG3D_1_1KDTree_1_1Iterator.html">Iterator</a> <a class="el" href="classG3D_1_1KDTree.html">G3D::KDTree</a>&lt; T, BoundsFunc, HashFunc, EqualsFunc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>C++ STL style iterator method. Returns the first member. <br />
Use preincrement (++entry) to get to the next element (iteration order is arbitrary). <br />
Do not modify the set while iterating. </p>

</div>
</div>
<a id="a38a36506242afbf40fe40a76df8e0296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38a36506242afbf40fe40a76df8e0296">&#9670;&nbsp;</a></span>beginBoxIntersection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class BoundsFunc  = BoundsTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classG3D_1_1KDTree_1_1BoxIntersectionIterator.html">BoxIntersectionIterator</a> <a class="el" href="classG3D_1_1KDTree.html">G3D::KDTree</a>&lt; T, BoundsFunc, HashFunc, EqualsFunc &gt;::beginBoxIntersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1AABox.html">AABox</a> &amp;&#160;</td>
          <td class="paramname"><em>box</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterates through the members that intersect the box </p>

</div>
</div>
<a id="a9a88cf5fd2d63c455d9b678a2a9bb68f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a88cf5fd2d63c455d9b678a2a9bb68f">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class BoundsFunc  = BoundsTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3D_1_1KDTree.html">G3D::KDTree</a>&lt; T, BoundsFunc, HashFunc, EqualsFunc &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Throws out all elements of the set. </p>

</div>
</div>
<a id="a02b54babcac6503a5dfeb23ac8827368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02b54babcac6503a5dfeb23ac8827368">&#9670;&nbsp;</a></span>cloneTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class BoundsFunc  = BoundsTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classG3D_1_1KDTree_1_1Node.html">Node</a>* <a class="el" href="classG3D_1_1KDTree.html">G3D::KDTree</a>&lt; T, BoundsFunc, HashFunc, EqualsFunc &gt;::cloneTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classG3D_1_1KDTree_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Recursively clone the passed in node tree, setting pointers for members in the memberTable as appropriate. called by the assignment operator. </p>

</div>
</div>
<a id="aaa19e0e92163b06ec755a7ffb4ae57e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa19e0e92163b06ec755a7ffb4ae57e4">&#9670;&nbsp;</a></span>computeBounds()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class BoundsFunc  = BoundsTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classG3D_1_1AABox.html">AABox</a> <a class="el" href="classG3D_1_1KDTree.html">G3D::KDTree</a>&lt; T, BoundsFunc, HashFunc, EqualsFunc &gt;::computeBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1KDTree_1_1Handle.html">Handle</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>beginIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>endIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the bounds of the sub array. Used by makeNode. </p>

</div>
</div>
<a id="a28f5deec7e4dcb90c8d133001d6c801a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28f5deec7e4dcb90c8d133001d6c801a">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class BoundsFunc  = BoundsTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classG3D_1_1KDTree.html">G3D::KDTree</a>&lt; T, BoundsFunc, HashFunc, EqualsFunc &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if this object is in the set, otherwise returns false. O(1) time. </p>

</div>
</div>
<a id="a82766e1ef20fc4b8846fcee66ca2081d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82766e1ef20fc4b8846fcee66ca2081d">&#9670;&nbsp;</a></span>deserializeStructure()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class BoundsFunc  = BoundsTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3D_1_1KDTree.html">G3D::KDTree</a>&lt; T, BoundsFunc, HashFunc, EqualsFunc &gt;::deserializeStructure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classG3D_1_1BinaryInput.html">BinaryInput</a> &amp;&#160;</td>
          <td class="paramname"><em>bi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clears the member table </p>

</div>
</div>
<a id="afa7d36dc8c68cd2db05fdd390e0520fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa7d36dc8c68cd2db05fdd390e0520fa">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class BoundsFunc  = BoundsTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classG3D_1_1KDTree_1_1Iterator.html">Iterator</a> <a class="el" href="classG3D_1_1KDTree.html">G3D::KDTree</a>&lt; T, BoundsFunc, HashFunc, EqualsFunc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>C++ STL style iterator method. Returns one after the last iterator element. </p>

</div>
</div>
<a id="a1d13c9b5240f8d2fa8fb398027006f4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d13c9b5240f8d2fa8fb398027006f4f">&#9670;&nbsp;</a></span>getIntersectingMembers() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class BoundsFunc  = BoundsTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classG3D_1_1KDTree.html">G3D::KDTree</a>&lt; T, BoundsFunc, HashFunc, EqualsFunc &gt;::getIntersectingMembers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Plane.html">Plane</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3D_1_1Array.html">Array</a>&lt; T *&gt; &amp;&#160;</td>
          <td class="paramname"><em>members</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3D_1_1KDTree_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>parentMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parentMask</td><td>The mask that this node returned from culledBy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1718bd49f69fa1a96a01232db2c9e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1718bd49f69fa1a96a01232db2c9e84">&#9670;&nbsp;</a></span>getIntersectingMembers() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class BoundsFunc  = BoundsTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3D_1_1KDTree.html">G3D::KDTree</a>&lt; T, BoundsFunc, HashFunc, EqualsFunc &gt;::getIntersectingMembers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Plane.html">Plane</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3D_1_1Array.html">Array</a>&lt; T *&gt; &amp;&#160;</td>
          <td class="paramname"><em>members</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns all members inside the set of planes. <br />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">members</td><td>The results are appended to this array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c2a4cda2ef51a23db37da7b7b96824e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c2a4cda2ef51a23db37da7b7b96824e">&#9670;&nbsp;</a></span>getIntersectingMembers() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class BoundsFunc  = BoundsTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3D_1_1KDTree.html">G3D::KDTree</a>&lt; T, BoundsFunc, HashFunc, EqualsFunc &gt;::getIntersectingMembers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1GCamera_1_1Frustum.html">GCamera::Frustum</a> &amp;&#160;</td>
          <td class="paramname"><em>frustum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3D_1_1Array.html">Array</a>&lt; T *&gt; &amp;&#160;</td>
          <td class="paramname"><em>members</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Typically used to find all visible objects inside the view frustum (see also <a class="el" href="classG3D_1_1GCamera.html#af380e4f4e5fb727da01e1d56412d4fc2">GCamera::getClipPlanes</a>)... i.e. all objects <b>not</b> culled by frustum.</p>
<p>Example: </p><pre>
   Array&lt;Object*&gt;  visible;
   tree.getIntersectingMembers(camera.frustum(), visible);
   // ... Draw all objects in the visible array.
 </pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">members</td><td>The results are appended to this array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47a3b4247b3c6f89b3c119a8d68df556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47a3b4247b3c6f89b3c119a8d68df556">&#9670;&nbsp;</a></span>getIntersectingMembers() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class BoundsFunc  = BoundsTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3D_1_1KDTree.html">G3D::KDTree</a>&lt; T, BoundsFunc, HashFunc, EqualsFunc &gt;::getIntersectingMembers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1AABox.html">AABox</a> &amp;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3D_1_1Array.html">Array</a>&lt; T *&gt; &amp;&#160;</td>
          <td class="paramname"><em>members</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Appends all members whose bounds intersect the box. See also <a class="el" href="classG3D_1_1KDTree.html#a38a36506242afbf40fe40a76df8e0296">KDTree::beginBoxIntersection</a>. </p>

</div>
</div>
<a id="a91a5f5fd6837107654019345828e4e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a5f5fd6837107654019345828e4e70">&#9670;&nbsp;</a></span>getIntersectingMembers() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class BoundsFunc  = BoundsTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3D_1_1KDTree.html">G3D::KDTree</a>&lt; T, BoundsFunc, HashFunc, EqualsFunc &gt;::getIntersectingMembers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Sphere.html">Sphere</a> &amp;&#160;</td>
          <td class="paramname"><em>sphere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3D_1_1Array.html">Array</a>&lt; T *&gt; &amp;&#160;</td>
          <td class="paramname"><em>members</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds all members whose bounding boxes intersect the sphere. The actual elements may not intersect the sphere. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">members</td><td>The results are appended to this array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e49dffef19b6ef687f6a277f2314ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e49dffef19b6ef687f6a277f2314ca6">&#9670;&nbsp;</a></span>getMembers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class BoundsFunc  = BoundsTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3D_1_1KDTree.html">G3D::KDTree</a>&lt; T, BoundsFunc, HashFunc, EqualsFunc &gt;::getMembers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classG3D_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>members</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an array of all members of the set. See also <a class="el" href="classG3D_1_1KDTree.html#a4ae7f0fa8924c0249a558b6e2d9921b1">KDTree::begin</a>. </p>

</div>
</div>
<a id="a857ab82721ac3e8b8f8bda2a3fd71157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a857ab82721ac3e8b8f8bda2a3fd71157">&#9670;&nbsp;</a></span>getPointer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class BoundsFunc  = BoundsTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classG3D_1_1KDTree.html">G3D::KDTree</a>&lt; T, BoundsFunc, HashFunc, EqualsFunc &gt;::getPointer </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If a value that is EqualsFunc to <em>value</em> is present, returns a pointer to the version stored in the data structure, otherwise returns NULL. </p>

</div>
</div>
<a id="a123584d0d7b24cae03644e35249892d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a123584d0d7b24cae03644e35249892d3">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class BoundsFunc  = BoundsTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3D_1_1KDTree.html">G3D::KDTree</a>&lt; T, BoundsFunc, HashFunc, EqualsFunc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts an object into the set if it is not already present. O(log n) time. Does not cause the tree to be balanced. </p>

</div>
</div>
<a id="a21b199944ac538cd1ee751868f8bc28d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21b199944ac538cd1ee751868f8bc28d">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class BoundsFunc  = BoundsTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3D_1_1KDTree.html">G3D::KDTree</a>&lt; T, BoundsFunc, HashFunc, EqualsFunc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>valueArray</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts each elements in the array in turn. If the tree begins empty (no structure and no elements), this is faster than inserting each element in turn. You still need to balance the tree at the end. </p>

</div>
</div>
<a id="a65fa03c5992256213ea9ec9d7a2c72f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65fa03c5992256213ea9ec9d7a2c72f6">&#9670;&nbsp;</a></span>intersectRay()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class BoundsFunc  = BoundsTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename RayCallback &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3D_1_1KDTree.html">G3D::KDTree</a>&lt; T, BoundsFunc, HashFunc, EqualsFunc &gt;::intersectRay </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Ray.html">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RayCallback &amp;&#160;</td>
          <td class="paramname"><em>intersectCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>intersectCallbackIsFast</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Invoke a callback for every member along a ray until the closest intersection is found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>either a function or an instance of a class with an overloaded operator() of the form:</td></tr>
  </table>
  </dd>
</dl>
<p><code>void callback(const Ray&amp; ray, const T&amp; object, float&amp; distance)</code>. If the ray hits the object before travelling distance <code>distance</code>, updates <code>distance</code> with the new distance to the intersection, otherwise leaves it unmodified. A common example is:</p>
<pre>
class Entity {
public:</pre><pre>           void intersect(const Ray&amp; ray, float&amp; maxDist, Vector3&amp; outLocation, Vector3&amp; outNormal) {
               float d = maxDist;</pre><pre>               // ... search for intersection distance d</pre><pre>               if ((d &gt; 0) &amp;&amp; (d &lt; maxDist)) {
                   // Intersection occured
                   maxDist = d;
                   outLocation = ...;
                   outNormal = ...;
               }
           }
       };</pre><pre>       // Finds the surface normal and location of the first intersection with the scene
       class Intersection {
       public:
           Entity*     closestEntity;
           <a class="el" href="classG3D_1_1Vector3.html">Vector3</a>     hitLocation;
           <a class="el" href="classG3D_1_1Vector3.html">Vector3</a>     hitNormal;</pre><pre>           void operator()(const Ray&amp; ray, const Entity* entity, float&amp; distance) {
               entity-&gt;intersect(ray, distance, hitLocation, hitNormal);
           }
       };</pre><pre>       KDTree&lt;Entity*&gt; scene;</pre><pre>       Intersection intersection;
       float distance = <a class="el" href="g3dmath_8h.html#a75b289f04a486b3026012c289513e4d8">finf()</a>;
       scene.intersectRay(camera.worldRay(x, y), intersection, distance);
     </pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">distance</td><td>When the method is invoked, this is the maximum distance that the tree should search for an intersection. On return, this is set to the distance to the first intersection encountered.</td></tr>
    <tr><td class="paramname">intersectCallbackIsFast</td><td>If false, each object's bounds are tested before the intersectCallback is invoked. If the intersect callback runs at the same speed or faster than AABox-ray intersection, set this to true. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0672440068e3a3b792c51a952b86c80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0672440068e3a3b792c51a952b86c80">&#9670;&nbsp;</a></span>makeNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class BoundsFunc  = BoundsTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classG3D_1_1KDTree_1_1Node.html">Node</a>* <a class="el" href="classG3D_1_1KDTree.html">G3D::KDTree</a>&lt; T, BoundsFunc, HashFunc, EqualsFunc &gt;::makeNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1KDTree_1_1Handle.html">Handle</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>valuesPerNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numMeanSplits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1KDTree_1_1Handle.html">Handle</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>temp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Recursively subdivides the subarray.</p>
<p>Clears the source array as soon as it is no longer needed.</p>
<p>Call assignSplitBounds() on the root node after making a tree. </p>

</div>
</div>
<a id="a739c5a93a109f2108be49935f6699e62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a739c5a93a109f2108be49935f6699e62">&#9670;&nbsp;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class BoundsFunc  = BoundsTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3D_1_1KDTree.html">G3D::KDTree</a>&lt; T, BoundsFunc, HashFunc, EqualsFunc &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes an object from the set in O(1) time. It is an error to remove members that are not already present. May unbalance the tree. <br />
 Removing an element never causes a node (split plane) to be removed... nodes are only changed when the tree is rebalanced. This behavior is desirable because it allows the split planes to be serialized, and then deserialized into an empty tree which can be repopulated. </p>

</div>
</div>
<a id="aa272a2ca9c758a603732e9197c3c25ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa272a2ca9c758a603732e9197c3c25ba">&#9670;&nbsp;</a></span>serializeStructure()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class BoundsFunc  = BoundsTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3D_1_1KDTree.html">G3D::KDTree</a>&lt; T, BoundsFunc, HashFunc, EqualsFunc &gt;::serializeStructure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classG3D_1_1BinaryOutput.html">BinaryOutput</a> &amp;&#160;</td>
          <td class="paramname"><em>bo</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores the locations of the splitting planes (the structure but not the content) so that the tree can be quickly rebuilt from a previous configuration without calling balance. </p>

</div>
</div>
<a id="a63839bda2d6dbfb182ab9c9e927b3d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63839bda2d6dbfb182ab9c9e927b3d2d">&#9670;&nbsp;</a></span>setContents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class BoundsFunc  = BoundsTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3D_1_1KDTree.html">G3D::KDTree</a>&lt; T, BoundsFunc, HashFunc, EqualsFunc &gt;::setContents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>valuesPerNode</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numMeanSplits</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear, set the contents to the values in the array, and then balance </p>

</div>
</div>
<a id="a6717d5d15e096cb53af03b88050b116e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6717d5d15e096cb53af03b88050b116e">&#9670;&nbsp;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class BoundsFunc  = BoundsTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3D_1_1KDTree.html">G3D::KDTree</a>&lt; T, BoundsFunc, HashFunc, EqualsFunc &gt;::update </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If the element is in the set, it is removed. The element is then inserted.</p>
<p>This is useful when the == and hashCode methods on <em>T</em> are independent of the bounds. In that case, you may call update(v) to insert an element for the first time and call update(v) again every time it moves to keep the tree up to date. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a8a35e683e0215aa3ca614babe498f7e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a35e683e0215aa3ca614babe498f7e5">&#9670;&nbsp;</a></span>memberTable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class BoundsFunc  = BoundsTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classG3D_1_1Table.html">MemberTable</a> <a class="el" href="classG3D_1_1KDTree.html">G3D::KDTree</a>&lt; T, BoundsFunc, HashFunc, EqualsFunc &gt;::memberTable</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maps members to the node containing them </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>dep/include/g3dlite/G3D/<a class="el" href="KDTree_8h_source.html">KDTree.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
