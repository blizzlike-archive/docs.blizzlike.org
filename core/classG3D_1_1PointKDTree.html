<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>blizzlike core: G3D::PointKDTree&lt; T, PositionFunc, HashFunc, EqualsFunc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">blizzlike core
   </div>
   <div id="projectbrief">mmorpg server</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>G3D</b></li><li class="navelem"><a class="el" href="classG3D_1_1PointKDTree.html">PointKDTree</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classG3D_1_1PointKDTree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">G3D::PointKDTree&lt; T, PositionFunc, HashFunc, EqualsFunc &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="PointKDTree_8h_source.html">PointKDTree.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1PointKDTree_1_1AxisComparator.html">AxisComparator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1PointKDTree_1_1BoxIntersectionIterator.html">BoxIntersectionIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1PointKDTree_1_1Handle.html">Handle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1PointKDTree_1_1Iterator.html">Iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1PointKDTree_1_1Node.html">Node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a896741054fd82db1fa788d1fd22ed0cc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1PointKDTree.html#a896741054fd82db1fa788d1fd22ed0cc">PointKDTree</a> ()</td></tr>
<tr class="separator:a896741054fd82db1fa788d1fd22ed0cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8426df6bafeb2556b9d112559a0fa718"><td class="memItemLeft" align="right" valign="top"><a id="a8426df6bafeb2556b9d112559a0fa718"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PointKDTree</b> (const <a class="el" href="classG3D_1_1PointKDTree.html">PointKDTree</a> &amp;src)</td></tr>
<tr class="separator:a8426df6bafeb2556b9d112559a0fa718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87579d57c86d0d6583672023a63dcea"><td class="memItemLeft" align="right" valign="top"><a id="ad87579d57c86d0d6583672023a63dcea"></a>
<a class="el" href="classG3D_1_1PointKDTree.html">PointKDTree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classG3D_1_1PointKDTree.html">PointKDTree</a> &amp;src)</td></tr>
<tr class="separator:ad87579d57c86d0d6583672023a63dcea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3325a1273df711bc014f6ce2eacfb6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1PointKDTree.html#ab3325a1273df711bc014f6ce2eacfb6c">clear</a> ()</td></tr>
<tr class="separator:ab3325a1273df711bc014f6ce2eacfb6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936ad3ed5cff8487e006e44d8590e738"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1PointKDTree.html#a936ad3ed5cff8487e006e44d8590e738">clearData</a> ()</td></tr>
<tr class="separator:a936ad3ed5cff8487e006e44d8590e738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fec96a9d4a1b23376e6e4b7a33c8d78"><td class="memItemLeft" align="right" valign="top"><a id="a0fec96a9d4a1b23376e6e4b7a33c8d78"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const</td></tr>
<tr class="separator:a0fec96a9d4a1b23376e6e4b7a33c8d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac44bfcedf8a7a0dffb746ca0bcd236a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1PointKDTree.html#ac44bfcedf8a7a0dffb746ca0bcd236a0">insert</a> (const T &amp;value)</td></tr>
<tr class="separator:ac44bfcedf8a7a0dffb746ca0bcd236a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb986faf5a1c3af4a0ed28115ab41040"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1PointKDTree.html#acb986faf5a1c3af4a0ed28115ab41040">insert</a> (const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; T &gt; &amp;valueArray)</td></tr>
<tr class="separator:acb986faf5a1c3af4a0ed28115ab41040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c1c5f3255fcdf5ca1e1b0ffb977594"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1PointKDTree.html#a02c1c5f3255fcdf5ca1e1b0ffb977594">contains</a> (const T &amp;value)</td></tr>
<tr class="separator:a02c1c5f3255fcdf5ca1e1b0ffb977594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e3be55829adc8eb338b74bfb0379c57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1PointKDTree.html#a3e3be55829adc8eb338b74bfb0379c57">remove</a> (const T &amp;value)</td></tr>
<tr class="separator:a3e3be55829adc8eb338b74bfb0379c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace264951d2521d4431eb90d4a7d9e04f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1PointKDTree.html#ace264951d2521d4431eb90d4a7d9e04f">update</a> (const T &amp;value)</td></tr>
<tr class="separator:ace264951d2521d4431eb90d4a7d9e04f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7934eec2a77c9c88897dbeeb44155370"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1PointKDTree.html#a7934eec2a77c9c88897dbeeb44155370">balance</a> (int valuesPerNode=40, int numMeanSplits=3)</td></tr>
<tr class="separator:a7934eec2a77c9c88897dbeeb44155370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1599912308957234af0b2106933bf0d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1PointKDTree.html#a1599912308957234af0b2106933bf0d3">getIntersectingMembers</a> (const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Plane.html">Plane</a> &gt; &amp;plane, <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; T &gt; &amp;members) const</td></tr>
<tr class="separator:a1599912308957234af0b2106933bf0d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a413acbb636a62903eb40f597e1ad0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1PointKDTree.html#a49a413acbb636a62903eb40f597e1ad0">getIntersectingMembers</a> (const <a class="el" href="classG3D_1_1GCamera_1_1Frustum.html">GCamera::Frustum</a> &amp;frustum, <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; T &gt; &amp;members) const</td></tr>
<tr class="separator:a49a413acbb636a62903eb40f597e1ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7fd0907e281b4030287ddfeee6b741"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classG3D_1_1PointKDTree_1_1BoxIntersectionIterator.html">BoxIntersectionIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1PointKDTree.html#a6c7fd0907e281b4030287ddfeee6b741">beginBoxIntersection</a> (const <a class="el" href="classG3D_1_1AABox.html">AABox</a> &amp;box) const</td></tr>
<tr class="separator:a6c7fd0907e281b4030287ddfeee6b741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae473ce68373e6acaa47d5b55970b212b"><td class="memItemLeft" align="right" valign="top"><a id="ae473ce68373e6acaa47d5b55970b212b"></a>
<a class="el" href="classG3D_1_1PointKDTree_1_1BoxIntersectionIterator.html">BoxIntersectionIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>endBoxIntersection</b> () const</td></tr>
<tr class="separator:ae473ce68373e6acaa47d5b55970b212b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae229edd72935b8d5761f40dbdbf8a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1PointKDTree.html#a7ae229edd72935b8d5761f40dbdbf8a3">getIntersectingMembers</a> (const <a class="el" href="classG3D_1_1AABox.html">AABox</a> &amp;box, <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; T &gt; &amp;members) const</td></tr>
<tr class="separator:a7ae229edd72935b8d5761f40dbdbf8a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1b68a55fd5594b67672c908d494732"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1PointKDTree.html#a8b1b68a55fd5594b67672c908d494732">getIntersectingMembers</a> (const <a class="el" href="classG3D_1_1Sphere.html">Sphere</a> &amp;sphere, <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; T &gt; &amp;members) const</td></tr>
<tr class="separator:a8b1b68a55fd5594b67672c908d494732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d2585dda4e70ce98cfb1589ddad0fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1PointKDTree.html#ac9d2585dda4e70ce98cfb1589ddad0fc">serializeStructure</a> (<a class="el" href="classG3D_1_1BinaryOutput.html">BinaryOutput</a> &amp;bo) const</td></tr>
<tr class="separator:ac9d2585dda4e70ce98cfb1589ddad0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73fa323ddbadb626dfb4081e41a0bffa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1PointKDTree.html#a73fa323ddbadb626dfb4081e41a0bffa">deserializeStructure</a> (<a class="el" href="classG3D_1_1BinaryInput.html">BinaryInput</a> &amp;bi)</td></tr>
<tr class="separator:a73fa323ddbadb626dfb4081e41a0bffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafdadc7a7b338af5eea1d48fa5f06c7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1PointKDTree.html#aafdadc7a7b338af5eea1d48fa5f06c7d">getMembers</a> (<a class="el" href="classG3D_1_1Array.html">Array</a>&lt; T &gt; &amp;members) const</td></tr>
<tr class="separator:aafdadc7a7b338af5eea1d48fa5f06c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4b7518901ba02c4821b7f956a88e5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classG3D_1_1PointKDTree_1_1Iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1PointKDTree.html#a2f4b7518901ba02c4821b7f956a88e5a">begin</a> () const</td></tr>
<tr class="separator:a2f4b7518901ba02c4821b7f956a88e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad354e9bd82fd546d9cedcdb28b27b0c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classG3D_1_1PointKDTree_1_1Iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1PointKDTree.html#ad354e9bd82fd546d9cedcdb28b27b0c4">end</a> () const</td></tr>
<tr class="separator:ad354e9bd82fd546d9cedcdb28b27b0c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:af66178c77c4934ca86b8196b350642c8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classG3D_1_1Table.html">Table</a>&lt; T, <a class="el" href="classG3D_1_1PointKDTree_1_1Node.html">Node</a> *, HashFunc, EqualsFunc &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1PointKDTree.html#af66178c77c4934ca86b8196b350642c8">MemberTable</a></td></tr>
<tr class="separator:af66178c77c4934ca86b8196b350642c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a5fb7075940201218e10a4b82f5a94117"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classG3D_1_1PointKDTree_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1PointKDTree.html#a5fb7075940201218e10a4b82f5a94117">makeNode</a> (<a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1PointKDTree_1_1Handle.html">Handle</a> &gt; &amp;source, <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1PointKDTree_1_1Handle.html">Handle</a> &gt; &amp;temp, int valuesPerNode, int numMeanSplits)</td></tr>
<tr class="separator:a5fb7075940201218e10a4b82f5a94117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70b553b6b4af4d6a5c9f2f2659968ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classG3D_1_1PointKDTree_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1PointKDTree.html#af70b553b6b4af4d6a5c9f2f2659968ec">cloneTree</a> (<a class="el" href="classG3D_1_1PointKDTree_1_1Node.html">Node</a> *src)</td></tr>
<tr class="separator:af70b553b6b4af4d6a5c9f2f2659968ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:ab3b82a814d13d3e552a1c76d06298166"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classG3D_1_1AABox.html">AABox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classG3D_1_1PointKDTree.html#ab3b82a814d13d3e552a1c76d06298166">computeBounds</a> (const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1PointKDTree_1_1Handle.html">Handle</a> &gt; &amp;point)</td></tr>
<tr class="separator:ab3b82a814d13d3e552a1c76d06298166"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ae337b85825efc662358ce6bbab08557f"><td class="memItemLeft" align="right" valign="top"><a id="ae337b85825efc662358ce6bbab08557f"></a>
<a class="el" href="classG3D_1_1PointKDTree.html#af66178c77c4934ca86b8196b350642c8">MemberTable</a>&#160;</td><td class="memItemRight" valign="bottom"><b>memberTable</b></td></tr>
<tr class="separator:ae337b85825efc662358ce6bbab08557f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a542dc55553b8015388d49d9fa01653ed"><td class="memItemLeft" align="right" valign="top"><a id="a542dc55553b8015388d49d9fa01653ed"></a>
<a class="el" href="classG3D_1_1PointKDTree_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>root</b></td></tr>
<tr class="separator:a542dc55553b8015388d49d9fa01653ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, class PositionFunc = PositionTrait&lt;T&gt;, class HashFunc = HashTrait&lt;T&gt;, class EqualsFunc = EqualsTrait&lt;T&gt;&gt;<br />
class G3D::PointKDTree&lt; T, PositionFunc, HashFunc, EqualsFunc &gt;</h3>

<p>A set data structure that supports spatial queries using an axis-aligned BSP tree for speed.</p>
<p><a class="el" href="classG3D_1_1PointKDTree.html">PointKDTree</a> allows you to quickly find points in 3D that lie within a box or sphere. For large sets of objects it is much faster than testing each object for a collision. See also <a class="el" href="classG3D_1_1KDTree.html">G3D::KDTree</a>; this class is optimized for point sets, e.g.,for use in photon mapping and mesh processing.</p>
<p><b>Template Parameters</b></p>
<p><br />
</p>
<p><br />
The template parameter <em>T</em> must be one for which the following functions are overloaded:</p>
<pre>
     T::T(); <em>(public constructor of no arguments)</em></pre><pre>      template&lt;&gt; struct PositionTrait&lt;class T&gt; {
        static void getPosition(const T&amp; v, G3D::Vector3&amp; p);};</pre><pre>      template &lt;&gt; struct HashTrait&lt;class T&gt; {
        static size_t hashCode(const T&amp; key);};</pre><pre>      template&lt;&gt; struct EqualsTrait&lt;class T&gt; {
          static bool equals(const T&amp; a, const T&amp; b); };
   </pre><p>G3D provides these for the <a class="el" href="classG3D_1_1Vector2.html">Vector2</a>, <a class="el" href="classG3D_1_1Vector3.html">Vector3</a>, and <a class="el" href="classG3D_1_1Vector4.html">Vector4</a> classes. If you use a custom class, or a pointer to a custom class, you will need to define those functions.</p>
<p><b>Moving Set Members</b> </p>
<p>It is important that objects do not move without updating the <a class="el" href="classG3D_1_1PointKDTree.html">PointKDTree</a>. If the position of an object is about to change, <a class="el" href="classG3D_1_1PointKDTree.html#a3e3be55829adc8eb338b74bfb0379c57">PointKDTree::remove</a> it before they change and <a class="el" href="classG3D_1_1PointKDTree.html#ac44bfcedf8a7a0dffb746ca0bcd236a0">PointKDTree::insert</a> it again afterward. For objects where the hashCode and == operator are invariant with respect to the 3D position, you can use the <a class="el" href="classG3D_1_1PointKDTree.html#ace264951d2521d4431eb90d4a7d9e04f">PointKDTree::update</a> method as a shortcut to insert/remove an object in one step after it has moved.</p>
<p>Note: Do not mutate any value once it has been inserted into <a class="el" href="classG3D_1_1PointKDTree.html">PointKDTree</a>. Values are copied interally. All <a class="el" href="classG3D_1_1PointKDTree.html">PointKDTree</a> iterators convert to pointers to constant values to reinforce this.</p>
<p>If you want to mutate the objects you intend to store in a <a class="el" href="classG3D_1_1PointKDTree.html">PointKDTree</a> simply insert <em>pointers</em> to your objects instead of the objects themselves, and ensure that the above operations are defined. (And actually, because values are copied, if your values are large you may want to insert pointers anyway, to save space and make the balance operation faster.)</p>
<p><b>Dimensions</b> Although designed as a 3D-data structure, you can use the <a class="el" href="classG3D_1_1PointKDTree.html">PointKDTree</a> for data distributed along 2 or 1 axes by simply returning bounds that are always zero along one or more dimensions. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="af66178c77c4934ca86b8196b350642c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af66178c77c4934ca86b8196b350642c8">&#9670;&nbsp;</a></span>MemberTable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class PositionFunc  = PositionTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classG3D_1_1Table.html">Table</a>&lt;T, <a class="el" href="classG3D_1_1PointKDTree_1_1Node.html">Node</a>*, HashFunc, EqualsFunc&gt; <a class="el" href="classG3D_1_1PointKDTree.html">G3D::PointKDTree</a>&lt; T, PositionFunc, HashFunc, EqualsFunc &gt;::<a class="el" href="classG3D_1_1PointKDTree.html#af66178c77c4934ca86b8196b350642c8">MemberTable</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maps members to the node containing them </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a896741054fd82db1fa788d1fd22ed0cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a896741054fd82db1fa788d1fd22ed0cc">&#9670;&nbsp;</a></span>PointKDTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class PositionFunc  = PositionTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classG3D_1_1PointKDTree.html">G3D::PointKDTree</a>&lt; T, PositionFunc, HashFunc, EqualsFunc &gt;::<a class="el" href="classG3D_1_1PointKDTree.html">PointKDTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>To construct a balanced tree, insert the elements and then call <a class="el" href="classG3D_1_1PointKDTree.html#a7934eec2a77c9c88897dbeeb44155370">PointKDTree::balance()</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7934eec2a77c9c88897dbeeb44155370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7934eec2a77c9c88897dbeeb44155370">&#9670;&nbsp;</a></span>balance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class PositionFunc  = PositionTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3D_1_1PointKDTree.html">G3D::PointKDTree</a>&lt; T, PositionFunc, HashFunc, EqualsFunc &gt;::balance </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>valuesPerNode</em> = <code>40</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numMeanSplits</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Rebalances the tree (slow). Call when objects have moved substantially from their original positions (which unbalances the tree and causes the spatial queries to be slow).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuesPerNode</td><td>Maximum number of elements to put at a node.</td></tr>
    <tr><td class="paramname">numMeanSplits</td><td>numMeanSplits = 0 gives a fully axis aligned BSP-tree, where the balance operation attempts to balance the tree so that every splitting plane has an equal number of left and right children (i.e. it is a <b>median</b> split along that axis). <br />
This tends to maximize average performance; all querries will return in the same amount of time.</td></tr>
  </table>
  </dd>
</dl>
<p>You can override this behavior by setting a number of <b>mean</b> (average) splits. numMeanSplits = MAX_INT creates a full oct-tree, which tends to optimize peak performance (some areas of the scene will terminate after few recursive splits) at the expense of peak performance. </p>

</div>
</div>
<a id="a2f4b7518901ba02c4821b7f956a88e5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f4b7518901ba02c4821b7f956a88e5a">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class PositionFunc  = PositionTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classG3D_1_1PointKDTree_1_1Iterator.html">Iterator</a> <a class="el" href="classG3D_1_1PointKDTree.html">G3D::PointKDTree</a>&lt; T, PositionFunc, HashFunc, EqualsFunc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>C++ STL style iterator method. Returns the first member. <br />
Use preincrement (++entry) to get to the next element (iteration order is arbitrary). <br />
Do not modify the set while iterating. </p>

</div>
</div>
<a id="a6c7fd0907e281b4030287ddfeee6b741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c7fd0907e281b4030287ddfeee6b741">&#9670;&nbsp;</a></span>beginBoxIntersection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class PositionFunc  = PositionTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classG3D_1_1PointKDTree_1_1BoxIntersectionIterator.html">BoxIntersectionIterator</a> <a class="el" href="classG3D_1_1PointKDTree.html">G3D::PointKDTree</a>&lt; T, PositionFunc, HashFunc, EqualsFunc &gt;::beginBoxIntersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1AABox.html">AABox</a> &amp;&#160;</td>
          <td class="paramname"><em>box</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterates through the members that intersect the box </p>

</div>
</div>
<a id="ab3325a1273df711bc014f6ce2eacfb6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3325a1273df711bc014f6ce2eacfb6c">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class PositionFunc  = PositionTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3D_1_1PointKDTree.html">G3D::PointKDTree</a>&lt; T, PositionFunc, HashFunc, EqualsFunc &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Throws out all elements of the set and erases the structure of the tree. </p>

</div>
</div>
<a id="a936ad3ed5cff8487e006e44d8590e738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a936ad3ed5cff8487e006e44d8590e738">&#9670;&nbsp;</a></span>clearData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class PositionFunc  = PositionTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3D_1_1PointKDTree.html">G3D::PointKDTree</a>&lt; T, PositionFunc, HashFunc, EqualsFunc &gt;::clearData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes all elements of the set while maintaining the structure of the tree </p>

</div>
</div>
<a id="af70b553b6b4af4d6a5c9f2f2659968ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af70b553b6b4af4d6a5c9f2f2659968ec">&#9670;&nbsp;</a></span>cloneTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class PositionFunc  = PositionTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classG3D_1_1PointKDTree_1_1Node.html">Node</a>* <a class="el" href="classG3D_1_1PointKDTree.html">G3D::PointKDTree</a>&lt; T, PositionFunc, HashFunc, EqualsFunc &gt;::cloneTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classG3D_1_1PointKDTree_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Recursively clone the passed in node tree, setting pointers for members in the memberTable as appropriate. called by the assignment operator. </p>

</div>
</div>
<a id="ab3b82a814d13d3e552a1c76d06298166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3b82a814d13d3e552a1c76d06298166">&#9670;&nbsp;</a></span>computeBounds()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class PositionFunc  = PositionTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classG3D_1_1AABox.html">AABox</a> <a class="el" href="classG3D_1_1PointKDTree.html">G3D::PointKDTree</a>&lt; T, PositionFunc, HashFunc, EqualsFunc &gt;::computeBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1PointKDTree_1_1Handle.html">Handle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the bounds of the sub array. Used by makeNode. </p>

</div>
</div>
<a id="a02c1c5f3255fcdf5ca1e1b0ffb977594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c1c5f3255fcdf5ca1e1b0ffb977594">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class PositionFunc  = PositionTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classG3D_1_1PointKDTree.html">G3D::PointKDTree</a>&lt; T, PositionFunc, HashFunc, EqualsFunc &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if this object is in the set, otherwise returns false. O(1) time. </p>

</div>
</div>
<a id="a73fa323ddbadb626dfb4081e41a0bffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73fa323ddbadb626dfb4081e41a0bffa">&#9670;&nbsp;</a></span>deserializeStructure()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class PositionFunc  = PositionTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3D_1_1PointKDTree.html">G3D::PointKDTree</a>&lt; T, PositionFunc, HashFunc, EqualsFunc &gt;::deserializeStructure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classG3D_1_1BinaryInput.html">BinaryInput</a> &amp;&#160;</td>
          <td class="paramname"><em>bi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clears the member table </p>

</div>
</div>
<a id="ad354e9bd82fd546d9cedcdb28b27b0c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad354e9bd82fd546d9cedcdb28b27b0c4">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class PositionFunc  = PositionTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classG3D_1_1PointKDTree_1_1Iterator.html">Iterator</a> <a class="el" href="classG3D_1_1PointKDTree.html">G3D::PointKDTree</a>&lt; T, PositionFunc, HashFunc, EqualsFunc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>C++ STL style iterator method. Returns one after the last iterator element. </p>

</div>
</div>
<a id="a1599912308957234af0b2106933bf0d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1599912308957234af0b2106933bf0d3">&#9670;&nbsp;</a></span>getIntersectingMembers() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class PositionFunc  = PositionTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3D_1_1PointKDTree.html">G3D::PointKDTree</a>&lt; T, PositionFunc, HashFunc, EqualsFunc &gt;::getIntersectingMembers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1Plane.html">Plane</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3D_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>members</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns all members inside the set of planes. <br />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">members</td><td>The results are appended to this array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49a413acbb636a62903eb40f597e1ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49a413acbb636a62903eb40f597e1ad0">&#9670;&nbsp;</a></span>getIntersectingMembers() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class PositionFunc  = PositionTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3D_1_1PointKDTree.html">G3D::PointKDTree</a>&lt; T, PositionFunc, HashFunc, EqualsFunc &gt;::getIntersectingMembers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1GCamera_1_1Frustum.html">GCamera::Frustum</a> &amp;&#160;</td>
          <td class="paramname"><em>frustum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3D_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>members</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Typically used to find all visible objects inside the view frustum (see also <a class="el" href="classG3D_1_1GCamera.html#af380e4f4e5fb727da01e1d56412d4fc2">GCamera::getClipPlanes</a>)... i.e. all objects <b>not</b> culled by frustum.</p>
<p>Example: </p><pre>
   Array&lt;Object*&gt;  visible;
   tree.getIntersectingMembers(camera.frustum(), visible);
   // ... Draw all objects in the visible array.
 </pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">members</td><td>The results are appended to this array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ae229edd72935b8d5761f40dbdbf8a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ae229edd72935b8d5761f40dbdbf8a3">&#9670;&nbsp;</a></span>getIntersectingMembers() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class PositionFunc  = PositionTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3D_1_1PointKDTree.html">G3D::PointKDTree</a>&lt; T, PositionFunc, HashFunc, EqualsFunc &gt;::getIntersectingMembers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1AABox.html">AABox</a> &amp;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3D_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>members</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Appends all members whose bounds intersect the box. See also <a class="el" href="classG3D_1_1PointKDTree.html#a6c7fd0907e281b4030287ddfeee6b741">PointKDTree::beginBoxIntersection</a>. </p>

</div>
</div>
<a id="a8b1b68a55fd5594b67672c908d494732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1b68a55fd5594b67672c908d494732">&#9670;&nbsp;</a></span>getIntersectingMembers() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class PositionFunc  = PositionTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3D_1_1PointKDTree.html">G3D::PointKDTree</a>&lt; T, PositionFunc, HashFunc, EqualsFunc &gt;::getIntersectingMembers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Sphere.html">Sphere</a> &amp;&#160;</td>
          <td class="paramname"><em>sphere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3D_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>members</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">members</td><td>The results are appended to this array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aafdadc7a7b338af5eea1d48fa5f06c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafdadc7a7b338af5eea1d48fa5f06c7d">&#9670;&nbsp;</a></span>getMembers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class PositionFunc  = PositionTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3D_1_1PointKDTree.html">G3D::PointKDTree</a>&lt; T, PositionFunc, HashFunc, EqualsFunc &gt;::getMembers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classG3D_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>members</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an array of all members of the set. See also <a class="el" href="classG3D_1_1PointKDTree.html#a2f4b7518901ba02c4821b7f956a88e5a">PointKDTree::begin</a>. </p>

</div>
</div>
<a id="ac44bfcedf8a7a0dffb746ca0bcd236a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac44bfcedf8a7a0dffb746ca0bcd236a0">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class PositionFunc  = PositionTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3D_1_1PointKDTree.html">G3D::PointKDTree</a>&lt; T, PositionFunc, HashFunc, EqualsFunc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts an object into the set if it is not already present. O(log n) time. Does not cause the tree to be balanced. </p>

</div>
</div>
<a id="acb986faf5a1c3af4a0ed28115ab41040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb986faf5a1c3af4a0ed28115ab41040">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class PositionFunc  = PositionTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3D_1_1PointKDTree.html">G3D::PointKDTree</a>&lt; T, PositionFunc, HashFunc, EqualsFunc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classG3D_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>valueArray</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts each elements in the array in turn. If the tree begins empty (no structure and no elements), this is faster than inserting each element in turn. You still need to balance the tree at the end. </p>

</div>
</div>
<a id="a5fb7075940201218e10a4b82f5a94117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb7075940201218e10a4b82f5a94117">&#9670;&nbsp;</a></span>makeNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class PositionFunc  = PositionTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classG3D_1_1PointKDTree_1_1Node.html">Node</a>* <a class="el" href="classG3D_1_1PointKDTree.html">G3D::PointKDTree</a>&lt; T, PositionFunc, HashFunc, EqualsFunc &gt;::makeNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1PointKDTree_1_1Handle.html">Handle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classG3D_1_1Array.html">Array</a>&lt; <a class="el" href="classG3D_1_1PointKDTree_1_1Handle.html">Handle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>temp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>valuesPerNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numMeanSplits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Recursively subdivides the subarray.</p>
<p>The source array will be cleared after it is used</p>
<p>Call assignSplitBounds() on the root node after making a tree. </p>

</div>
</div>
<a id="a3e3be55829adc8eb338b74bfb0379c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e3be55829adc8eb338b74bfb0379c57">&#9670;&nbsp;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class PositionFunc  = PositionTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3D_1_1PointKDTree.html">G3D::PointKDTree</a>&lt; T, PositionFunc, HashFunc, EqualsFunc &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes an object from the set in O(1) time. It is an error to remove members that are not already present. May unbalance the tree. <br />
 Removing an element never causes a node (split plane) to be removed... nodes are only changed when the tree is rebalanced. This behavior is desirable because it allows the split planes to be serialized, and then deserialized into an empty tree which can be repopulated. </p>

</div>
</div>
<a id="ac9d2585dda4e70ce98cfb1589ddad0fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d2585dda4e70ce98cfb1589ddad0fc">&#9670;&nbsp;</a></span>serializeStructure()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class PositionFunc  = PositionTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3D_1_1PointKDTree.html">G3D::PointKDTree</a>&lt; T, PositionFunc, HashFunc, EqualsFunc &gt;::serializeStructure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classG3D_1_1BinaryOutput.html">BinaryOutput</a> &amp;&#160;</td>
          <td class="paramname"><em>bo</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores the locations of the splitting planes (the structure but not the content) so that the tree can be quickly rebuilt from a previous configuration without calling balance. </p>

</div>
</div>
<a id="ace264951d2521d4431eb90d4a7d9e04f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace264951d2521d4431eb90d4a7d9e04f">&#9670;&nbsp;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class PositionFunc  = PositionTrait&lt;T&gt;, class HashFunc  = HashTrait&lt;T&gt;, class EqualsFunc  = EqualsTrait&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classG3D_1_1PointKDTree.html">G3D::PointKDTree</a>&lt; T, PositionFunc, HashFunc, EqualsFunc &gt;::update </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If the element is in the set, it is removed. The element is then inserted.</p>
<p>This is useful when the == and hashCode methods on <em>T</em> are independent of the bounds. In that case, you may call update(v) to insert an element for the first time and call update(v) again every time it moves to keep the tree up to date. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>dep/include/g3dlite/G3D/<a class="el" href="PointKDTree_8h_source.html">PointKDTree.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
